<<<<<<< HEAD
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var PropTypes = tslib_1.__importStar(require("prop-types"));
function makeDefaultQueryInfo() {
    return {
        seen: false,
        observable: null,
    };
}
var RenderPromises = (function () {
    function RenderPromises() {
        this.queryPromises = new Map();
        this.queryInfoTrie = new Map();
    }
    RenderPromises.prototype.registerSSRObservable = function (queryInstance, observable) {
        this.lookupQueryInfo(queryInstance).observable = observable;
    };
    RenderPromises.prototype.getSSRObservable = function (queryInstance) {
        return this.lookupQueryInfo(queryInstance).observable;
    };
    RenderPromises.prototype.addQueryPromise = function (queryInstance, finish) {
        var info = this.lookupQueryInfo(queryInstance);
        if (!info.seen) {
            this.queryPromises.set(queryInstance, new Promise(function (resolve) {
                resolve(queryInstance.fetchData());
            }));
            return null;
        }
        return finish();
    };
    RenderPromises.prototype.hasPromises = function () {
        return this.queryPromises.size > 0;
    };
    RenderPromises.prototype.consumeAndAwaitPromises = function () {
        var _this = this;
        var promises = [];
        this.queryPromises.forEach(function (promise, queryInstance) {
            _this.lookupQueryInfo(queryInstance).seen = true;
            promises.push(promise);
        });
        this.queryPromises.clear();
        return Promise.all(promises);
    };
    RenderPromises.prototype.lookupQueryInfo = function (queryInstance) {
        var queryInfoTrie = this.queryInfoTrie;
        var _a = queryInstance.props, query = _a.query, variables = _a.variables;
        var varMap = queryInfoTrie.get(query) || new Map();
        if (!queryInfoTrie.has(query))
            queryInfoTrie.set(query, varMap);
        var variablesString = JSON.stringify(variables);
        var info = varMap.get(variablesString) || makeDefaultQueryInfo();
        if (!varMap.has(variablesString))
            varMap.set(variablesString, info);
        return info;
    };
    return RenderPromises;
}());
exports.RenderPromises = RenderPromises;
function getDataFromTree(tree, context) {
    if (context === void 0) { context = {}; }
    return getMarkupFromTree({
        tree: tree,
        context: context,
        renderFunction: require("react-dom/server").renderToStaticMarkup,
    });
}
exports.default = getDataFromTree;
function getMarkupFromTree(_a) {
    var tree = _a.tree, _b = _a.context, context = _b === void 0 ? {} : _b, _c = _a.renderFunction, renderFunction = _c === void 0 ? require("react-dom/server").renderToStaticMarkup : _c;
    var renderPromises = new RenderPromises();
    var RenderPromisesProvider = (function (_super) {
        tslib_1.__extends(RenderPromisesProvider, _super);
        function RenderPromisesProvider() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        RenderPromisesProvider.prototype.getChildContext = function () {
            return tslib_1.__assign({}, context, { renderPromises: renderPromises });
        };
        RenderPromisesProvider.prototype.render = function () {
            return tree;
        };
        RenderPromisesProvider.childContextTypes = {
            renderPromises: PropTypes.object,
        };
        return RenderPromisesProvider;
    }(React.Component));
    Object.keys(context).forEach(function (key) {
        RenderPromisesProvider.childContextTypes[key] = PropTypes.any;
    });
    function process() {
        var html = renderFunction(React.createElement(RenderPromisesProvider));
        return renderPromises.hasPromises()
            ? renderPromises.consumeAndAwaitPromises().then(process)
            : html;
    }
    return Promise.resolve().then(process);
}
exports.getMarkupFromTree = getMarkupFromTree;
=======
import * as React from 'react';
function getProps(element) {
    return element.props || element.attributes;
}
function isReactElement(element) {
    return !!element.type;
}
function isComponentClass(Comp) {
    return Comp.prototype && (Comp.prototype.render || Comp.prototype.isReactComponent);
}
function providesChildContext(instance) {
    return !!instance.getChildContext;
}
export function walkTree(element, context, visitor, newContext) {
    if (newContext === void 0) { newContext = new Map(); }
    if (!element) {
        return;
    }
    if (Array.isArray(element)) {
        element.forEach(function (item) { return walkTree(item, context, visitor, newContext); });
        return;
    }
    if (isReactElement(element)) {
        if (typeof element.type === 'function') {
            var Comp = element.type;
            var props = Object.assign({}, Comp.defaultProps, getProps(element));
            var childContext_1 = context;
            var child = void 0;
            if (isComponentClass(Comp)) {
                var instance_1 = new Comp(props, context);
                Object.defineProperty(instance_1, 'props', {
                    value: instance_1.props || props,
                });
                instance_1.context = instance_1.context || context;
                instance_1.state = instance_1.state || null;
                instance_1.setState = function (newState) {
                    if (typeof newState === 'function') {
                        newState = newState(instance_1.state, instance_1.props, instance_1.context);
                    }
                    instance_1.state = Object.assign({}, instance_1.state, newState);
                };
                if (Comp.getDerivedStateFromProps) {
                    var result = Comp.getDerivedStateFromProps(instance_1.props, instance_1.state);
                    if (result !== null) {
                        instance_1.state = Object.assign({}, instance_1.state, result);
                    }
                }
                else if (instance_1.UNSAFE_componentWillMount) {
                    instance_1.UNSAFE_componentWillMount();
                }
                else if (instance_1.componentWillMount) {
                    instance_1.componentWillMount();
                }
                if (providesChildContext(instance_1)) {
                    childContext_1 = Object.assign({}, context, instance_1.getChildContext());
                }
                if (visitor(element, instance_1, newContext, context, childContext_1) === false) {
                    return;
                }
                child = instance_1.render();
            }
            else {
                if (visitor(element, null, newContext, context) === false) {
                    return;
                }
                child = Comp(props, context);
            }
            if (child) {
                if (Array.isArray(child)) {
                    child.forEach(function (item) { return walkTree(item, childContext_1, visitor, newContext); });
                }
                else {
                    walkTree(child, childContext_1, visitor, newContext);
                }
            }
        }
        else if (element.type._context || element.type.Consumer) {
            if (visitor(element, null, newContext, context) === false) {
                return;
            }
            var child = void 0;
            if (!!element.type._context) {
                newContext = new Map(newContext);
                newContext.set(element.type, element.props.value);
                child = element.props.children;
            }
            else {
                var value = element.type._currentValue;
                if (newContext.has(element.type.Provider)) {
                    value = newContext.get(element.type.Provider);
                }
                child = element.props.children(value);
            }
            if (child) {
                if (Array.isArray(child)) {
                    child.forEach(function (item) { return walkTree(item, context, visitor, newContext); });
                }
                else {
                    walkTree(child, context, visitor, newContext);
                }
            }
        }
        else {
            if (visitor(element, null, newContext, context) === false) {
                return;
            }
            if (element.props && element.props.children) {
                React.Children.forEach(element.props.children, function (child) {
                    if (child) {
                        walkTree(child, context, visitor, newContext);
                    }
                });
            }
        }
    }
    else if (typeof element === 'string' || typeof element === 'number') {
        visitor(element, null, newContext, context);
    }
}
function hasFetchDataFunction(instance) {
    return typeof instance.fetchData === 'function';
}
function isPromise(promise) {
    return typeof promise.then === 'function';
}
function getPromisesFromTree(_a) {
    var rootElement = _a.rootElement, rootContext = _a.rootContext, rootNewContext = _a.rootNewContext;
    var promises = [];
    walkTree(rootElement, rootContext, function (_, instance, newContext, context, childContext) {
        if (instance && hasFetchDataFunction(instance)) {
            var promise = instance.fetchData();
            if (isPromise(promise)) {
                promises.push({
                    promise: promise,
                    context: childContext || context,
                    instance: instance,
                    newContext: newContext,
                });
                return false;
            }
        }
    }, rootNewContext);
    return promises;
}
function getDataAndErrorsFromTree(rootElement, rootContext, storeError, rootNewContext) {
    if (rootNewContext === void 0) { rootNewContext = new Map(); }
    var promises = getPromisesFromTree({ rootElement: rootElement, rootContext: rootContext, rootNewContext: rootNewContext });
    if (!promises.length) {
        return Promise.resolve();
    }
    var mappedPromises = promises.map(function (_a) {
        var promise = _a.promise, context = _a.context, instance = _a.instance, newContext = _a.newContext;
        return promise
            .then(function (_) { return getDataAndErrorsFromTree(instance.render(), context, storeError, newContext); })
            .catch(function (e) { return storeError(e); });
    });
    return Promise.all(mappedPromises);
}
function processErrors(errors) {
    switch (errors.length) {
        case 0:
            break;
        case 1:
            throw errors.pop();
        default:
            var wrapperError = new Error(errors.length + " errors were thrown when executing your fetchData functions.");
            wrapperError.queryErrors = errors;
            throw wrapperError;
    }
}
export default function getDataFromTree(rootElement, rootContext) {
    if (rootContext === void 0) { rootContext = {}; }
    var errors = [];
    var storeError = function (error) { return errors.push(error); };
    return getDataAndErrorsFromTree(rootElement, rootContext, storeError).then(function (_) {
        return processErrors(errors);
    });
}
>>>>>>> b22d4f639358533e1bbd355b77d7a3342c6a63e8
//# sourceMappingURL=getDataFromTree.js.map