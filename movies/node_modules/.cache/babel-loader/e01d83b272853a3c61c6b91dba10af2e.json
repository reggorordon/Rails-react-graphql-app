{"ast":null,"code":"\"use strict\";\n/* eslint-disable camelcase, no-process-env */\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) {\n      if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n  }\n\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar React = require(\"react\");\n\nvar react_dom_1 = require(\"react-dom\");\n\nvar target_1 = require(\"./target\");\n\nvar isValidElement = React.isValidElement,\n    Children = React.Children;\n\nfunction FirstChild(props) {\n  var childrenArray = React.Children.toArray(props.children);\n  return childrenArray[0] || null;\n}\n\nexports.FirstChild = FirstChild;\n\nfunction getDisplayName(Component) {\n  return Component.displayName || Component.name || 'Component';\n}\n\nexports.getDisplayName = getDisplayName; // Wraps `element` in `Component`, if it is not already an instance of\n// `Component`. If `props` is passed, those will be added as props on the\n// wrapped component. If `element` is null, the component is not wrapped.\n\nfunction wrapWithComponent(element, Component, props) {\n  if (element == null) {\n    return null;\n  }\n\n  return isElementOfType(element, Component) ? element : React.createElement(Component, __assign({}, props), element);\n}\n\nexports.wrapWithComponent = wrapWithComponent;\n\nfunction hotReloadComponentCheck(AComponent, AnotherComponent) {\n  var componentName = AComponent.name;\n  var anotherComponentName = AnotherComponent.displayName;\n  return AComponent === AnotherComponent || Boolean(componentName) && componentName === anotherComponentName;\n} // In development, we compare based on the name of the function because\n// React Hot Loader proxies React components in order to make updates. In\n// production we can simply compare the components for equality.\n\n\nvar isComponent = process.env.NODE_ENV === 'development' ? hotReloadComponentCheck : function (AComponent, AnotherComponent) {\n  return AComponent === AnotherComponent;\n}; // Checks whether `element` is a React element of type `Component` (or one of\n// the passed components, if `Component` is an array of React components).\n\nfunction isElementOfType(element, Component) {\n  if (element == null || !isValidElement(element) || typeof element.type === 'string') {\n    return false;\n  }\n\n  var type = element.type;\n  var Components = Array.isArray(Component) ? Component : [Component];\n  return Components.some(function (AComponent) {\n    return typeof type !== 'string' && isComponent(AComponent, type);\n  });\n}\n\nexports.isElementOfType = isElementOfType; // Returns all children that are valid elements as an array. Can optionally be\n// filtered by passing `predicate`.\n\nfunction elementChildren(children, predicate) {\n  if (predicate === void 0) {\n    predicate = function predicate() {\n      return true;\n    };\n  }\n\n  return Children.toArray(children).filter(function (child) {\n    return isValidElement(child) && predicate(child);\n  });\n}\n\nexports.elementChildren = elementChildren; // Adds the `methods` to the prototype of `Component`, with any existing\n// methods of the same name still being called *after* they version supplied\n// by `methods`. Returns the newly-augmented class.\n\nfunction augmentComponent(Component, methods) {\n  Object.keys(methods).forEach(function (name) {\n    var method = methods[name];\n\n    if (typeof method !== 'function') {\n      return;\n    }\n\n    var currentMethod = Component.prototype[name];\n\n    Component.prototype[name] = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      if (typeof currentMethod === 'function') {\n        currentMethod.call.apply(currentMethod, [this].concat(args));\n      }\n\n      method.call.apply(method, [this].concat(args));\n    };\n  });\n  return Component;\n}\n\nexports.augmentComponent = augmentComponent;\nvar layerIndex = 1;\n\nfunction layeredComponent(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  function uniqueID() {\n    var idPrefix = options.idPrefix;\n    return idPrefix + \"Layer\" + layerIndex++;\n  }\n\n  return function createLayeredComponent(Component) {\n    return augmentComponent(Component, {\n      componentWillMount: function componentWillMount() {\n        if (target_1.isServer) {\n          return;\n        }\n\n        var node = document.createElement('div');\n        node.id = uniqueID();\n        this.layerNode = node;\n      },\n      componentDidMount: function componentDidMount() {\n        if (target_1.isServer) {\n          return;\n        }\n\n        document.body.appendChild(this.layerNode);\n        this.renderLayerToNode();\n      },\n      componentDidUpdate: function componentDidUpdate() {\n        if (target_1.isServer) {\n          return;\n        }\n\n        this.renderLayerToNode();\n      },\n      renderLayerToNode: function renderLayerToNode() {\n        if (target_1.isServer) {\n          return;\n        }\n\n        var layerOutput = this.renderLayer() || React.createElement(\"span\", null);\n        this.layerOutput = layerOutput;\n        react_dom_1.unstable_renderSubtreeIntoContainer(this, layerOutput, this.layerNode);\n      },\n      componentWillUnmount: function componentWillUnmount() {\n        if (target_1.isServer) {\n          return;\n        }\n\n        var layerNode = this.layerNode;\n        react_dom_1.unmountComponentAtNode(layerNode);\n        document.body.removeChild(layerNode);\n      }\n    });\n  };\n}\n\nexports.layeredComponent = layeredComponent;","map":null,"metadata":{},"sourceType":"script"}