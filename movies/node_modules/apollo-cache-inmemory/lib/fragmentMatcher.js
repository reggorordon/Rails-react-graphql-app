<<<<<<< HEAD
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var apollo_utilities_1 = require("apollo-utilities");
var ts_invariant_1 = require("ts-invariant");
var haveWarned = false;
function shouldWarn() {
    var answer = !haveWarned;
    if (!apollo_utilities_1.isTest()) {
        haveWarned = true;
    }
    return answer;
}
=======
import { isTest, warnOnceInDevelopment } from 'apollo-utilities';
var haveWarned = false;
>>>>>>> b22d4f639358533e1bbd355b77d7a3342c6a63e8
var HeuristicFragmentMatcher = (function () {
    function HeuristicFragmentMatcher() {
    }
    HeuristicFragmentMatcher.prototype.ensureReady = function () {
        return Promise.resolve();
    };
    HeuristicFragmentMatcher.prototype.canBypassInit = function () {
        return true;
    };
    HeuristicFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {
        var obj = context.store.get(idValue.id);
        if (!obj && idValue.id === 'ROOT_QUERY') {
            return true;
        }
        if (!obj) {
            return false;
        }
        if (!obj.__typename) {
<<<<<<< HEAD
            if (shouldWarn()) {
                ts_invariant_1.invariant.warn("You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.");
                ts_invariant_1.invariant.warn('Could not find __typename on Fragment ', typeCondition, obj);
                ts_invariant_1.invariant.warn("DEPRECATION WARNING: using fragments without __typename is unsupported behavior " +
                    "and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.");
=======
            if (!haveWarned) {
                console.warn("You're using fragments in your queries, but either don't have the addTypename:\n  true option set in Apollo Client, or you are trying to write a fragment to the store without the __typename.\n   Please turn on the addTypename option and include __typename when writing fragments so that Apollo Client\n   can accurately match fragments.");
                console.warn('Could not find __typename on Fragment ', typeCondition, obj);
                console.warn("DEPRECATION WARNING: using fragments without __typename is unsupported behavior " +
                    "and will be removed in future versions of Apollo client. You should fix this and set addTypename to true now.");
                if (!isTest()) {
                    haveWarned = true;
                }
>>>>>>> b22d4f639358533e1bbd355b77d7a3342c6a63e8
            }
            return 'heuristic';
        }
        if (obj.__typename === typeCondition) {
            return true;
        }
<<<<<<< HEAD
        if (shouldWarn()) {
            ts_invariant_1.invariant.error('You are using the simple (heuristic) fragment matcher, but your ' +
                'queries contain union or interface types. Apollo Client will not be ' +
                'able to accurately map fragments. To make this error go away, use ' +
                'the `IntrospectionFragmentMatcher` as described in the docs: ' +
                'https://www.apollographql.com/docs/react/advanced/fragments.html#fragment-matcher');
        }
=======
        warnOnceInDevelopment('You are using the simple (heuristic) fragment matcher, but your ' +
            'queries contain union or interface types. Apollo Client will not be ' +
            'able to accurately map fragments. To make this error go away, use ' +
            'the `IntrospectionFragmentMatcher` as described in the docs: ' +
            'https://www.apollographql.com/docs/react/recipes/fragment-matching.html', 'error');
>>>>>>> b22d4f639358533e1bbd355b77d7a3342c6a63e8
        return 'heuristic';
    };
    return HeuristicFragmentMatcher;
}());
<<<<<<< HEAD
exports.HeuristicFragmentMatcher = HeuristicFragmentMatcher;
=======
export { HeuristicFragmentMatcher };
>>>>>>> b22d4f639358533e1bbd355b77d7a3342c6a63e8
var IntrospectionFragmentMatcher = (function () {
    function IntrospectionFragmentMatcher(options) {
        if (options && options.introspectionQueryResultData) {
            this.possibleTypesMap = this.parseIntrospectionResult(options.introspectionQueryResultData);
            this.isReady = true;
        }
        else {
            this.isReady = false;
        }
        this.match = this.match.bind(this);
    }
    IntrospectionFragmentMatcher.prototype.match = function (idValue, typeCondition, context) {
<<<<<<< HEAD
        ts_invariant_1.invariant(this.isReady, 'FragmentMatcher.match() was called before FragmentMatcher.init()');
=======
        if (!this.isReady) {
            throw new Error('FragmentMatcher.match() was called before FragmentMatcher.init()');
        }
>>>>>>> b22d4f639358533e1bbd355b77d7a3342c6a63e8
        var obj = context.store.get(idValue.id);
        if (!obj) {
            return false;
        }
<<<<<<< HEAD
        ts_invariant_1.invariant(obj.__typename, "Cannot match fragment because __typename property is missing: " + JSON.stringify(obj));
=======
        if (!obj.__typename) {
            throw new Error("Cannot match fragment because __typename property is missing: " + JSON.stringify(obj));
        }
>>>>>>> b22d4f639358533e1bbd355b77d7a3342c6a63e8
        if (obj.__typename === typeCondition) {
            return true;
        }
        var implementingTypes = this.possibleTypesMap[typeCondition];
        if (implementingTypes && implementingTypes.indexOf(obj.__typename) > -1) {
            return true;
        }
        return false;
    };
    IntrospectionFragmentMatcher.prototype.parseIntrospectionResult = function (introspectionResultData) {
        var typeMap = {};
        introspectionResultData.__schema.types.forEach(function (type) {
            if (type.kind === 'UNION' || type.kind === 'INTERFACE') {
                typeMap[type.name] = type.possibleTypes.map(function (implementingType) { return implementingType.name; });
            }
        });
        return typeMap;
    };
    return IntrospectionFragmentMatcher;
}());
<<<<<<< HEAD
exports.IntrospectionFragmentMatcher = IntrospectionFragmentMatcher;
=======
export { IntrospectionFragmentMatcher };
>>>>>>> b22d4f639358533e1bbd355b77d7a3342c6a63e8
//# sourceMappingURL=fragmentMatcher.js.map