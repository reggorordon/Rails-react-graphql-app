/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */
<<<<<<< HEAD

'use strict';

var Promise = require('./Promise');

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var ExecutionEnvironment = require('./ExecutionEnvironment');

var sprintf = require('./sprintf');
var fetch = require('./fetch');
var warning = require('./warning');

var DEFAULT_TIMEOUT = 15000;
var DEFAULT_RETRIES = [1000, 3000];

=======
'use strict';

var Promise = require("./Promise");

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var ExecutionEnvironment = require("./ExecutionEnvironment");

var sprintf = require("./sprintf");

var fetch = require("./fetch");

var warning = require("./warning");

var DEFAULT_TIMEOUT = 15000;
var DEFAULT_RETRIES = [1000, 3000];
>>>>>>> b22d4f639358533e1bbd355b77d7a3342c6a63e8
/**
 * Makes a POST request to the server with the given data as the payload.
 * Automatic retries are done based on the values in `retryDelays`.
 */
<<<<<<< HEAD
=======

>>>>>>> b22d4f639358533e1bbd355b77d7a3342c6a63e8
function fetchWithRetries(uri, initWithRetries) {
  var _ref = initWithRetries || {},
      fetchTimeout = _ref.fetchTimeout,
      retryDelays = _ref.retryDelays,
<<<<<<< HEAD
      init = _objectWithoutProperties(_ref, ['fetchTimeout', 'retryDelays']);

  var _fetchTimeout = fetchTimeout != null ? fetchTimeout : DEFAULT_TIMEOUT;
=======
      init = _objectWithoutPropertiesLoose(_ref, ["fetchTimeout", "retryDelays"]);

  var _fetchTimeout = fetchTimeout != null ? fetchTimeout : DEFAULT_TIMEOUT;

>>>>>>> b22d4f639358533e1bbd355b77d7a3342c6a63e8
  var _retryDelays = retryDelays != null ? retryDelays : DEFAULT_RETRIES;

  var requestsAttempted = 0;
  var requestStartTime = 0;
  return new Promise(function (resolve, reject) {
    /**
     * Sends a request to the server that will timeout after `fetchTimeout`.
     * If the request fails or times out a new request might be scheduled.
     */
    function sendTimedRequest() {
      requestsAttempted++;
      requestStartTime = Date.now();
      var isRequestAlive = true;
      var request = fetch(uri, init);
      var requestTimeout = setTimeout(function () {
        isRequestAlive = false;
<<<<<<< HEAD
        if (shouldRetry(requestsAttempted)) {
          process.env.NODE_ENV !== 'production' ? warning(false, 'fetchWithRetries: HTTP timeout, retrying.') : void 0;
=======

        if (shouldRetry(requestsAttempted)) {
          process.env.NODE_ENV !== "production" ? warning(false, 'fetchWithRetries: HTTP timeout, retrying.') : void 0;
>>>>>>> b22d4f639358533e1bbd355b77d7a3342c6a63e8
          retryRequest();
        } else {
          reject(new Error(sprintf('fetchWithRetries(): Failed to get response from server, ' + 'tried %s times.', requestsAttempted)));
        }
      }, _fetchTimeout);
<<<<<<< HEAD

      request.then(function (response) {
        clearTimeout(requestTimeout);
=======
      request.then(function (response) {
        clearTimeout(requestTimeout);

>>>>>>> b22d4f639358533e1bbd355b77d7a3342c6a63e8
        if (isRequestAlive) {
          // We got a response, we can clear the timeout.
          if (response.status >= 200 && response.status < 300) {
            // Got a response code that indicates success, resolve the promise.
            resolve(response);
          } else if (shouldRetry(requestsAttempted)) {
            // Fetch was not successful, retrying.
            // TODO(#7595849): Only retry on transient HTTP errors.
<<<<<<< HEAD
            process.env.NODE_ENV !== 'production' ? warning(false, 'fetchWithRetries: HTTP error, retrying.') : void 0, retryRequest();
=======
            process.env.NODE_ENV !== "production" ? warning(false, 'fetchWithRetries: HTTP error, retrying.') : void 0, retryRequest();
>>>>>>> b22d4f639358533e1bbd355b77d7a3342c6a63e8
          } else {
            // Request was not successful, giving up.
            var error = new Error(sprintf('fetchWithRetries(): Still no successful response after ' + '%s retries, giving up.', requestsAttempted));
            error.response = response;
            reject(error);
          }
        }
<<<<<<< HEAD
      })['catch'](function (error) {
        clearTimeout(requestTimeout);
=======
      })["catch"](function (error) {
        clearTimeout(requestTimeout);

>>>>>>> b22d4f639358533e1bbd355b77d7a3342c6a63e8
        if (shouldRetry(requestsAttempted)) {
          retryRequest();
        } else {
          reject(error);
        }
      });
    }
<<<<<<< HEAD

=======
>>>>>>> b22d4f639358533e1bbd355b77d7a3342c6a63e8
    /**
     * Schedules another run of sendTimedRequest based on how much time has
     * passed between the time the last request was sent and now.
     */
<<<<<<< HEAD
    function retryRequest() {
      var retryDelay = _retryDelays[requestsAttempted - 1];
      var retryStartTime = requestStartTime + retryDelay;
      // Schedule retry for a configured duration after last request started.
      setTimeout(sendTimedRequest, retryStartTime - Date.now());
    }

    /**
     * Checks if another attempt should be done to send a request to the server.
     */
=======


    function retryRequest() {
      var retryDelay = _retryDelays[requestsAttempted - 1];
      var retryStartTime = requestStartTime + retryDelay; // Schedule retry for a configured duration after last request started.

      setTimeout(sendTimedRequest, retryStartTime - Date.now());
    }
    /**
     * Checks if another attempt should be done to send a request to the server.
     */


>>>>>>> b22d4f639358533e1bbd355b77d7a3342c6a63e8
    function shouldRetry(attempt) {
      return ExecutionEnvironment.canUseDOM && attempt <= _retryDelays.length;
    }

    sendTimedRequest();
  });
}

module.exports = fetchWithRetries;