/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @providesModule PromiseMap
 * @flow
 */
<<<<<<< HEAD

'use strict';

const Deferred = require('./Deferred');

const invariant = require('./invariant');

=======
'use strict';

const Deferred = require("./Deferred");

const invariant = require("./invariant");
>>>>>>> b22d4f639358533e1bbd355b77d7a3342c6a63e8
/**
 * A map of asynchronous values that can be get or set in any order. Unlike a
 * normal map, setting the value for a particular key more than once throws.
 * Also unlike a normal map, a key can either be resolved or rejected.
 */
<<<<<<< HEAD
class PromiseMap<Tvalue, Treason> {
  _deferred: { [key: string]: Deferred<any, any> };
=======


class PromiseMap<Tvalue, Treason> {
  _deferred: {
    [key: string]: Deferred<any, any>
  };
>>>>>>> b22d4f639358533e1bbd355b77d7a3342c6a63e8

  constructor() {
    this._deferred = {};
  }

  get(key: string): Promise<any> {
    return getDeferred(this._deferred, key).getPromise();
  }

  resolveKey(key: string, value: Tvalue): void {
    const entry = getDeferred(this._deferred, key);
    invariant(!entry.isSettled(), 'PromiseMap: Already settled `%s`.', key);
    entry.resolve(value);
  }

  rejectKey(key: string, reason: Treason): void {
    const entry = getDeferred(this._deferred, key);
    invariant(!entry.isSettled(), 'PromiseMap: Already settled `%s`.', key);
    entry.reject(reason);
  }
<<<<<<< HEAD
}

function getDeferred(entries: { [key: string]: Deferred<any, any> }, key: string): Deferred<any, any> {
  if (!entries.hasOwnProperty(key)) {
    entries[key] = new Deferred();
  }
=======

}

function getDeferred(entries: {
  [key: string]: Deferred<any, any>
}, key: string): Deferred<any, any> {
  if (!entries.hasOwnProperty(key)) {
    entries[key] = new Deferred();
  }

>>>>>>> b22d4f639358533e1bbd355b77d7a3342c6a63e8
  return entries[key];
}

module.exports = PromiseMap;